#+TITLE: Regional Module Code Documentation
#+DATE: August 10, 2015
#+AUTHOR: Oscar Alberto Quijano Xacur and Mohamad Elmasri
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:t p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:nil toc:nil todo:t |:t
#+OPTIONS:   H:4 num:t toc:3 p:t ^:nil
#+CREATOR: Emacs 24.4.1 (Org mode 8.2.10)
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+latex_header: \usepackage{float}
#+latex_header: \floatstyle{ruled}
#+latex_header: \newfloat{code}{h}{txt}
#+latex_header: \floatname{code}{Code example}

#+startup: nofold
#+SETUPFILE: css/theme-readtheorg-local.setup


This document explains how to process data for the RMS questionnaire
using python code instead of the GUI. 

* Importing the Library
First import the library =rmquestionnaire= in =RMS\Libraries=, a code example is below.

#+latex: \begin{code}

#+BEGIN_SRC python :session Python :exports code
  import sys,os
  os.chdir(path_to_main_RMS_folder)
  sys.path.append('Libraries')
  from rmquestionnaire import *
#+END_SRC

#+latex: \caption{Library import}\end{code}

Replace =path_to_main_RMS_folder= for a string  with the full path to
your main RMS folder.

* Importing 

In order to import data from a questionnaire the =questionnaire= class
should be used. Four arguments are needed when an object from this
class is defined: the excel file, the database file and the log folder
and a username .

#+latex: \begin{code}
#+BEGIN_SRC python :session Python :exports code
  excel_file="Regional_Survey_2015.xlsx"
  database_file= "Database/Prod.db"     # Concatenating the path of the main folder and the database subfolder.
  log_folder="/tmp/log/"
  username="user"
  qobject=questionnaire(excel_file,database_file,log_folder,username)
#+END_SRC

#+RESULTS:

#+latex: \caption{Library import}\end{code}

By initiating the =qobject= as shown above, the class reads the file
to know if the questionnaire is being imported for the first time or
if it is an edited questionnaire and what Database type to use
i.e. OBS, REP or EST. Also, =questionnaire= checks that the country
name used in the file exist the database, otherwise, an error is
raised.

* Preprocessing
  :PROPERTIES:
  :ORDERED:  t
  :END:

** Validation
Before extracting the data there is a validation step that takes
place. This is done by the method called *validation* in the
questionnaire class. It works by calling in order the following
methods from the class.

+ check_nadm1 :: Returns ~True~ if the number of administrative
     divissions is filled and ~False~ otherwise.
+ check_adm1_label :: Returns ~True~ if the label of administrative
     divissions is filled (e.g. state, province, etc. ) and ~False~
     otherwise.
+ check_adm1_names :: Returns ~True~ if the name of each
     administrative division if filled and ~False~ otherwise.
+ check_reference_year :: Returns ~True~ if the reference year (Cell
     M14 in the Administrative divisions sheet) is filled in the
     questionnaire.
+ check_country_name :: Returns ~True~ if the country name is filled
     and ~False~ otherwise.
+ check_number_of_sheets :: Returns ~False~ for an original
     questionnaire where the number of sheets does not coincide with
     the number of sheets originally provided in the questionnaire. In
     any other case it returns ~True~.
+ check_edited_configuration_part :: Returns ~False~ for an edited
     questionnaire without the information table in the top left
     corner. In any other case it returns ~True~.
+ check_values :: Checks that all the values reported in the
     questionnaire are a positive integer or a reference or
     A,N,Z,M. If this is the case it returns ~True~, otherwise it
     returns ~False~.

*validation* returns ~True~ when all of these checks return ~True~. If
at least one of them returns ~False~, *validation* returns ~False~ and
in this case the questionnaire should not be processed. A summary with
some information of the questionnaire and the results of the checks is
written in a file with name syntax =countryname_datetime_validation.txt= in
the =Log= folder.

** Data Report

After a successful validation step, there might be missing data or
inconsistencies or in the questionnaire data. These are not considered
an impediment for processing the questionnaire. They are reported in a
file with name syntax =countryname_datetime_data_report.csv= in the
=Log= folder.

The data report is generated by the method *write_data_report* in the
questionnaire class. It is a csv file divided in three parts.

The first part is called "Missing data". It gives the sheet name, table
name and columns that contain missing data in the questionnaire.

The second part is called "Data Issues". The following four types of
inconsistencies are reported in this section.

1. Undefined references. This is, a cell with the value X with no
   column number.
2. In each table they are some columns whose values should be smaller
   than the values of other columns. When this does not happen it is
   reported. This check is done with the method *check_less*. In this
   method there is a dictionary called =check_less_dictionary= whose
   keys are table names and the values are a list of pairs with column
   numbers. For each pair in the list the first column should have
   smaller values than the first ones. Extra checks of this type can
   be easily added by just adding the desired columns to this dictionary.
3. There are some groups of columns that added should give other
   columns (for example private plus public should give the
   total). When this does not happen this is written in the data
   report. The check is done with the method *check_column_sums*. In
   this method the local dictionary variable
   =check_columns_sums_dictionary= has keys with table names and the
   values are lists of pairs. The first element of each pair is a
   list of column numbers whose values should add to the column number
   given as second element of the pair. Is is possible to easily add
   more checks of this type by just editing this dictionary.
4. The values of all the regions should add to the country total. The
   cases where this does not happen are reported. This is done with
   the help of the method *check_region_totals*.

The third and last part of the data report consists of a list of all
the items in the Checking sheet of the questionnaire that have the
value No.

Before calling the *write_data_report* method it is necessary to call
the other following three methods: *check_region_totals*,
*check_less*, *check_column_sums*. These methods populate the
attribute =data_issues_dictionary= that is used by
*write_data_report*.

The following code performs the validation step and data report for
the example we have been developing.


#+BEGIN_SRC python :session Python :exports code
  if qobject.validation():
      qobject.check_region_totals()
      qobject.check_less()
      qobject.check_column_sums()
      qobject.write_data_report()
#+END_SRC



* Data extraction and comments
The =extract_data= method reads the values and enters them in the
database. It also writes the region names to the regions database if
an original questionnaire is being imported. The values are also
inserted in the audit trail table with the current timestamp.
 
There are two different types of comments, the ones from excel that
every cell can have and the ones that are part of the questionnaire
and that are on the top of each table. The first ones we call them
cell comments and the second ones table comments. Cell comments can be
imported to the database with the  =extract_comments= method an table
comments with the =extract_table_comments= method.

The following lines of code extract the data, cell comments and table
comments and add them to the database.

#+latex: \begin{code}

#+BEGIN_SRC python :session Python :export code
    qobject.extract_data()
    qobject.extract_comments()
    qobject.extract_table_comments()
#+END_SRC

#+RESULTS:

#+latex: \end{code}

* Exporting Data

** Exporting questionnaire data

In order to export the questionnaire data from the database to an
excel file, the =xlsxwriter= modules needs to be used in combination
with the function =export_var=. Is is also necessary to call the
function *set_database_file* which receives as only argument the full
path to the database file. The call to this function is necessary
since one want might to interact with the database without importing a
questionnaire. This can be done with this function.  As shown in the
following example, first the excel workbook needs to be created and
then =export_var= needs to be called for each desired sheet.

#+latex: \begin{code}

  #+BEGIN_SRC python :session Python :export code
    import xlsxwriter
    set_database_file('Database/Prod.db')
    co_code = qobject.country_code
    co_name = qobject.country_name
    year = qobject.emco_year

    filename = "{0}_{1}.xlsx".format(co_name, 2015)

    wb = xlsxwriter.Workbook(filename)

    export_var('Administrative divisions', wb, co_code, year, var_type = "sheet")
    export_var('Pupils', wb, co_code, year, var_type = "sheet")
    export_var('Teachers ISCED 1', wb, co_code, year, var_type = "sheet")
    export_var('Teachers ISCED 2', wb, co_code, year, var_type = "sheet")
    export_var('Teachers ISCED 3', wb, co_code, year, var_type = "sheet")
    export_var('Teachers ISCED 23', wb, co_code, year, var_type = "sheet")
    wb.close()
  #+END_SRC

After running this code an excel file with name syntax
=countryname_2015.xlsx= is created containing the data of all the
sheets that were passed to *export_var* before ~wb.close()~.

** Exporting indicators
It is also possible to export an excel file with the values of all the
indicators or for one of them. This can be achieved with the function
*export_indc*. In order for this function to work it is also necessary
to first call the function ~set_database_file~.


#+latex: \caption{Exporting from excel}\end{code}

#  LocalWords:  RMS Quijano Xacur Mohamad Elmasri num pri tex toc txt
#  LocalWords:  timestamp todo noexport usepackage floatstyle SRC sys
#  LocalWords:  newfloat floatname rmquestionnaire xlsx qobject emco
#  LocalWords:  xlsxwriter filename wb gui
#  LocalWords:  ISCED
