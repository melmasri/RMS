#+TITLE: Regional Module Code Documentation
#+DATE: August 10, 2015
#+AUTHOR: Oscar Alberto Quijano Xacur and Mohamad Elmasri
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:t p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:nil toc:nil todo:t |:t
#+OPTIONS:   H:4 num:t toc:3 p:t ^:nil
#+CREATOR: Emacs 24.4.1 (Org mode 8.2.10)
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+latex_header: \usepackage{float}
#+latex_header: \floatstyle{ruled}
#+latex_header: \newfloat{code}{h}{txt}
#+latex_header: \floatname{code}{Code example}

#+startup: nofold
#+SETUPFILE: css/theme-readtheorg-local.setup


This section explains how to process questionnaire data for the RMS questionnaire
using Python code directly, instead of the Graphical User Interface (GUI). The first
step is to import the library =rmquestionnaire= in =RMS\Libraries=, you can use the following code example.

#+latex: \begin{code}

#+BEGIN_SRC python :session Python :exports code :tangle technical_script_example.py :cache yes
  import sys,os
  os.chdir(path_to_main_RMS_folder)    # replace path_to_main_RMS_folder
  sys.path.append('Libraries')
  from rmquestionnaire import *
#+END_SRC

#+RESULTS:

#+latex: \caption{Library import}\end{code}

Replace =path_to_main_RMS_folder= for a string  with the full path to
your main RMS folder.

* Processing a Questionnaire

In order to import data from a questionnaire the =questionnaire= class
should be used. Four arguments are needed when an object from this
class is initiated: the excel file name, the database file path and the log folder path and a user name. The following is an example.

#+latex: \begin{code}
#+BEGIN_SRC python :session Python :exports code :tangle technical_script_example.py :cache yes
  excel_file="Regional_Survey_2015.xlsx"
  database_file= "Database/Prod.db"
  log_folder="/tmp/log/"
  username="user"
  qobject=questionnaire(excel_file,database_file,log_folder,username)
#+END_SRC
#+latex: \caption{Instating the questoinnaire class}\end{code}


By initiating the =qobject= as shown above, the class reads the file
to know if the questionnaire is being imported for the first time or
if it is an ~Edit~ mode questionnaire and what database series to use
i.e. OBS, REP or EST. Also, =questionnaire= checks that the country
name used in the file exist the in database, otherwise, an error is
raised.

** Preprocessing

*** Validation
Before extracting the data there is a validation step that takes
place, similar to when using the GUI. This is done by the method called *validation* in the
=questionnaire= class. It works by calling in order the following
methods from the class.

+ check_nadm1 :: Returns ~True~ if the number of administrative
     divisions is filled and ~False~ otherwise.
+ check_adm1_label :: Returns ~True~ if the label of administrative
     divisions is filled (e.g. state, province, etc. ) and ~False~
     otherwise.
+ check_adm1_names :: Returns ~True~ if the name of each
     administrative division if filled and ~False~ otherwise.
+ check_reference_year :: Returns ~True~ if the reference year (Cell
     ~M14~ in the Administrative divisions sheet) is filled in the
     questionnaire.
+ check_country_name :: Returns ~True~ if the country name is filled
     and ~False~ otherwise.
+ check_number_of_sheets :: Returns ~False~ for an original
     questionnaire where the number of sheets does not coincide with
     the number of sheets originally provided in the questionnaire. In
     any other case it returns ~True~.
+ check_edited_configuration_part :: Returns ~False~ for an edited
     questionnaire without the information table in the top left
     corner. In any other case it returns ~True~.
+ check_values :: Checks that all the values reported in the
     questionnaire are a positive integer or a reference or
     A,N,Z,M. If this is the case it returns ~True~, otherwise it
     returns ~False~.

*validation* returns ~True~ when all of these checks return ~True~. If
at least one of them returns ~False~, *validation* returns ~False~ and
in this case the questionnaire should not be processed. A validation report with
some information of the questionnaire and the results of the checks is
written in a file with name syntax =countryname_datetime_validation.txt= in
the =Log= folder.

Using the previous code box, you can run this as 

#+latex: \begin{code}
#+BEGIN_SRC python :session Python :exports code :tangle technical_script_example.py :cache yes
  qobject.validation()
#+END_SRC
#+latex: \caption{Instating the questoinnaire class}\end{code}



*** Data Report

After a successful validation step, there might be missing data or inconsistencies in the questionnaire. These are not considered
an impediment for processing the questionnaire. They are reported in the data report; a
file with name syntax =countryname_datetime_data_report.csv= saved to the 
=Log= folder.

The data report is generated by the method *write_data_report* in the
~questionnaire~ class. It is a csv file divided in three parts.

The first part is called "Missing data". It lists the sheet name, table
name and columns that contain missing data in the questionnaire.

The second part is called "Data Issues". The following four types of
inconsistencies are reported in this section.

1. Undefined references. This is a cell with the value X with no
   column number.
2. In the cases where some columns should have values smaller
   than others in different columns,the method *check_less* validates these cases. In this
   method there is a dictionary called =check_less_dictionary= whose
   keys are table names and the values are a list of pairs with column
   numbers. For each pair in the list the first column should have
   smaller values than the first ones. Extra checks of this type can
   be easily added by just adding the desired columns to this dictionary.
3. There are some groups of columns when added should give other
   columns (for example private and public should give the
   total). When this does not happen this is written in the data
   report. The check is done with the method *check_column_sums*. In
   this method the local dictionary variable
   =check_columns_sums_dictionary= has keys with table names and the
   values are lists of pairs. The first element of each pair is a
   list of column numbers whose values should add to the column number
   given as second element of the pair. It is possible to easily add
   more checks of this type by just editing this dictionary.
4. The values of all the regions should add to the country total. The
   cases where this does not happen are reported. This is done with
   the help of the method *check_region_totals*.

The third and last part of the data report consists of a list of all
the items in the ~Checking sheet~ of the questionnaire that have the
value ~No~.

Before calling the *write_data_report* method it is necessary to call
the following three methods: *check_region_totals*,
*check_less*, *check_column_sums*. These methods populate the
attribute =data_issues_dictionary= that is used by
*write_data_report*.

The following code performs the validation step and data report for
the example we have been developing.

#+latex: \begin{code}
#+BEGIN_SRC python :session Python :exports code :tangle technical_script_example.py :cache yes
  if qobject.validation():
      qobject.check_region_totals()
      qobject.check_less()
      qobject.check_column_sums()
      qobject.write_data_report()
#+END_SRC
#+latex: \caption{Validation and Data Report}\end{code}


** Data and Comments Extraction   
The =extract_data= method reads the values and enters them in the
database. It also writes the region names to the regions database if
an original questionnaire is being inserted the first time. The values are also
inserted in the audit trail table  with the current timestamp, if there is a change from the previously inserted version.


There are two different types of comments, cell comments and table comments. The cell comments are part of Excel functionality, while table comments are on the top of each table in the questionnaire. Cell comments can be
imported to the database with the  =extract_comments= method and table
comments with the =extract_table_comments= method.

The following lines of code extract the data, cell comments and table
comments and add them to the database.


#+latex: \begin{code}

#+BEGIN_SRC python :session Python :export code :tangle technical_script_example.py :cache yes
    qobject.extract_data()
    qobject.extract_comments()
    qobject.extract_table_comments()
#+END_SRC

#+RESULTS:

#+latex: \caption{Extracting Data and Comments} \end{code}

*** TODO
    + add audit trail ref.

* Computing Indicators

After extracting the data and putting it in the database it is
possible to compute indicators. The indicators are only computed form
the 'EST' series. At this point we have imported the data to the
reported series ('REP'). We need to copy the data to the estimated
series ('EST') in order to compute the indicators. This can be
achieved using the *moveSerie* function. Before using this function it
is necessary to tell the program what database file is being
used. This is done with the function *set_database_file* which
receives as the only argument the full path to the database file. It was
done this way since one might want to interact with the database
without importing a questionnaire.

#+latex: \begin{code}
#+BEGIN_SRC python :session Python :export code :tangle technical_script_example.py :cache yes
  set_database_file('Database/Prod.db')
  co_code = qobject.country_code
  year = qobject.emco_year
  from_serie='REP'
  to_serie='EST'
  moveSerie(co_code, year, from_serie, to_serie)
#+END_SRC
#+latex: \caption{Moving data to the EST series}\end{code}


After the EST series have been populated, we can compute the
indicators. This is done with the *rmindicators* class. After having
instantiated an object of this class for the desired country and year,
the method *compute_all_indicators* will compute and fill the
indicators table. Here is example code which instantiates this class
for the data used in the example script being developed along this
section.


#+latex: \begin{code}
#+BEGIN_SRC python :session Python :export code :tangle technical_script_example.py :cache yes
  database="Database/Prod.db"
  emco_year=2015
  country_name="Lao People's Democratic Republic"
  ind_object=indicators("Database/Prod.db",2015,"Lao People's Democratic Republic",username)
  ind_object.compute_all_indicators()
#+END_SRC
#+latex: \caption{Computing indicators}\end{code}


* Exporting Data

** Exporting questionnaire data

In order to export the questionnaire data from the database to an
excel file, the =xlsxwriter= modules needs to be used in combination
with the function =export_var=. As shown in the following example,
first the excel workbook needs to be created and then =export_var=
needs to be called for each desired sheet.

#+latex: \begin{code}

  #+BEGIN_SRC python :session Python :export code :tangle technical_script_example.py :cache yes
    import xlsxwriter
        
    co_name = qobject.country_name    
    filename = "{0}_{1}.xlsx".format(co_name, 2015)

    wb = xlsxwriter.Workbook(filename)

    export_var('Administrative divisions', wb, co_code, year, var_type = "sheet")
    export_var('Pupils', wb, co_code, year, var_type = "sheet")
    export_var('Teachers ISCED 1', wb, co_code, year, var_type = "sheet",serie= 'REP')
    export_var('Teachers ISCED 2', wb, co_code, year, var_type = "sheet",serie= 'REP')
    export_var('Teachers ISCED 3', wb, co_code, year, var_type = "sheet",serie= 'REP')
    export_var('Teachers ISCED 23', wb, co_code, year, var_type = "sheet",serie= 'REP')
    wb.close()
  #+END_SRC
#+latex: \caption{Exporting data to an excel file}\end{code}

After running this code an excel file with name syntax
=countryname_2015.xlsx= is created containing the data of all the
sheets that were passed to *export_var* before ~wb.close()~. Notice
that ~serie~ can take one of the values 'REP', 'OBS' or 'EST' which
correspond to reported, observed and estimated database respectively.

** Exporting indicators
It is also possible to export an excel file with the values of all the
indicators or for one of them. This can be achieved with the function
*export_indc*. In order for this function to work it is also necessary
to first call the function ~set_database_file~.

One can export one indicator or all of then to an excel
file. If ~All~ is passed as an argument to *export_indc* then all the
indicators are exported. The other option is to pass the name
indicator ID of the desired indicator (e.g. 'NTP.1').

#+latex: \begin{code}
#+BEGIN_SRC python :session Python :export code :tangle technical_script_example.py :cache yes
    indicators_filename="{0}_{1}_indicators.xlsx".format(co_name, 2015)
    indicators_wb = xlsxwriter.Workbook(indicators_filename)
    export_indc("All", indicators_wb, co_code, year)
    indicators_wb.close()
#+END_SRC
#+latex: \caption{Exporting indicators to an excel file }\end{code}



#  LocalWords:  RMS Quijano Xacur Mohamad Elmasri num pri tex toc txt
#  LocalWords:  timestamp todo noexport usepackage floatstyle SRC sys
#  LocalWords:  newfloat floatname rmquestionnaire xlsx qobject emco
#  LocalWords:  xlsxwriter filename wb gui
#  LocalWords:  ISCED
