#+TITLE: Indicators documentation
#+DATE: December 17th, 2015
#+AUTHOR: Oscar Alberto Quijano Xacur
#+EMAIL: oscar.quijano@use.startmail.com
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:{} arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:t p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:t todo:t |:t
#+CREATOR: Emacs 24.4.1 (Org mode 8.2.10)
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export

#+SETUPFILE: css/theme-readtheorg-local.setup

#+startup: content


* Adding  Indicators

** The indicators class
   The indicators class has three types of methods that we have
   decided to call with the following names: auxiliary methods,
   indicators methods and action methods.

   The auxiliary methods are an aid either for the computation of
   indicators or for sqlite interaction. Examples of these methods
   are: =get_nadm1=, =set_database_connection=, =get_country_code=,
   =column_operation=, =compute_percentages=.

   The indicator methods, are methods that compute the value of an
   indicator and adds their values to the sqlite database. Examples of
   these functions are: =pupils_teachers_ratio=, =newly_recruited_teachers=,
   =teachers_percentage_female=, =percentage_trained_teachers=,
   =percentage_private_teachers=, =percentage_non_permanent_teachers=.

   There are only two action methods: =compute_all_indicators= and
   =__init__=. The first one is a method that calls all the indicator
   methods. The second one, as for all classes is called when a class
   is instantiated.
   
** New indicators   
   
   If it is needed to add a new indicator, two things need to be
   done. First a method that computes the values of the indicator and
   adds them to the database should be added. After this, a call to
   this method should be added to =compute_all_indicators=. After this
   is done, the GUI will also compute this method when the calculate
   button is pressed.

   Before adding a method as explained in the paragraph before, one
   usually wants to test a new indicator in a different file without
   modifying the main code. Now we give an example of how to do this.

   The first thing that needs to be done is to add the =rmquestionnaire=
   library to our script. Since it is not installed in a folder where
   python can find it, we need to do this by hand. This can be achieved
   with the following code

   #+BEGIN_SRC python :session example1 :export code :tangle ind_test1.py
     import sys, os

     os.chdir('/home/oscar/RMS')
     #os.chdir(path_to_main_RMS_folder)
     sys.path.append('Libraries')

     from rmquestionnaire import *
   #+END_SRC

   #+RESULTS:

   The only thing that needs to be adapted form the code above is the
   instead the path to the main folder of the program in your computer
   should be used. After doing this, we can create a class testing
   class for the new indicators. Let us say that we want to compute
   the proportion of teachers in public schools in ISCED1 that have
   one or two years of experience. Let us call this indicator
   "PT.1.Pu.Exp1t2". This would correspond to dividing "T.1.Pu.Exp1t2"
   by "T.1.Pu". The method =column_operation= is very handy in this
   case. This indicator can be coded in the following way:


   #+BEGIN_SRC python :session example1 :export code :tangle ind_test1.py
     class tests_indicators(indicators):
         def proportion_public_teachers_1t2exp_isced1(self):
             # The following is a dictionary used for inserting the value in the database
             ind_dict={}
             indicator_name="PT.1.Pu.Exp1t2"
             indicator_values=self.column_operation(["T.1.Pu.Exp1t2",0],["T.1.Pu",0],div)
             # We prepare a dictionary for the function write_indic_sql
             ind_dict[indicator_name]=indicator_values
             self.write_indic_sql(ind_dict)
   #+END_SRC

   =column operation= applies a function to two alphanumeric codes for
   all the regions and also at the country level. The first two
   arguments have the form =[AC,year]=, where AC is an alphanumeric
   code and year is either 0 or 1. 0 stands for the value of the
   current year and -1 for the previous year. The third argument is a
   function, in the example above =div=. This function has to take two
   arguments of the form =[fig, symbol]= (it can be a list or a
   tupple). =symbol= has to be one of the following: 'a', 'm', 'n',
   'x' or 'value' depending if the data is not applicable, missing,
   null, a reference or a number respectively. =fig= is the value to
   which the operation if going to be applied. The function has also
   to return a pair =[value, symbol]=, where value is the result of
   the function applied to the values received and symbol is as
   before. There library has already the functions =sum=, =prod= and
   =div=, that compute the sum, multiplication and division according
   to the algebra. 

   After the definition of the test class. We can test the new
   indicator with the following code

   #+BEGIN_SRC python :session example1 :export code :tangle ind_test1.py
     test_object=tests_indicators("/home/oscar/RMS/Database/Prod.db",2015,"Lao People's Democratic Republic",'test_user')
     #test_object=tests_indicators(path_to_database,year,country_name,'test_user')
     test_object.proportion_public_teachers_1t2exp_isced1()
   #+END_SRC

   where =path_to_database= is a string with the full path to the
   database file, =year= the emco year for which the indicator is
   being computed and country_name the name of the country for which
   it is being calculated. In order for this to work, a questionnaire
   for the corresponding country and year should have been already
   imported to the database. After running the command above, it is
   possible to check the computed indicator directly in the
   database. To do this, open the database with sqlite and run the
   following command:

   #+BEGIN_SRC sqlite
     select IND_ID ,ADM_CODE, FIG from  EDU_INDICATOR_EST AS A JOIN COUNTRY AS B ON A.CO_CODE = B.CO_CODE WHERE B.CO_LONG_NAME= country_name ;
   #+END_SRC

   Notice that =country_name= above has to be changed for the actual
   name of the country you are using for the test. At this part you
   can check if you are getting the correct values (compared for
   example to computing them by hand). If they are not, you can modify
   the function that computes the indicator, until it gives the right
   values.

   Let us say that now you feel confident with your indicator function
   and that you want it to be included in the indicators computed by
   the GUI. What you need to do is to copy your method that computes
   the indicator into the indicators class in the
   =/RMS/Libraries/rmindicators.py= file. After doing this you need to
   add a call to this method in the =compute_all_indicators=.
